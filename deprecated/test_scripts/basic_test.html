<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Smart Scaling Basic Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a1a;
      color: #ffffff;
    }
    .header {
      background: #2a2a2a;
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .container {
      width: 800px;
      height: 500px;
      margin: 20px auto;
      border: 1px solid #3a3a3a;
    }
    button {
      padding: 5px 10px;
      background: #3a3a3a;
      color: white;
      border: 1px solid #4a4a4a;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    .status {
      margin-top: 10px;
      padding: 10px;
      background: #2a2a2a;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h3 style="margin: 0;">Smart Scaling Test</h3>
  </div>
  
  <div class="container" id="chart"></div>
  
  <div class="controls">
    <button id="load-data">Load Test Data</button>
    <button id="fit-chart">Fit Chart</button>
    <button id="toggle-auto">Toggle Auto-Scale</button>
    <button id="zoom-in">Zoom In</button>
    <button id="zoom-out">Zoom Out</button>
  </div>
  
  <div class="status" id="status">Status: Ready</div>
  
  <!-- Add direct script refs for testing -->
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  
  <script>
    // SmartScaling implementation for test
    class SmartScaling {
      constructor(chart, series) {
        this.chart = chart;
        this.series = series;
        this.isManualScale = false;
        this.lastVisibleRange = null;
        this.margins = {
          top: 0.2,
          bottom: 0.1
        };
        
        this.setupEventHandlers();
      }
      
      setupEventHandlers() {
        // Detect manual adjustments
        this.chart.subscribeClick(param => {
          if (param.point && param.point.y < 40) {
            this.isManualScale = true;
            updateStatus("Manual scaling activated");
          }
        });
        
        // Auto-scale on viewport change
        this.chart.timeScale().subscribeVisibleTimeRangeChange(() => {
          if (!this.isManualScale) {
            this.autoScaleToVisible();
          }
        });
        
        // Double-click to reset
        this.chart.subscribeDoubleClick(param => {
          if (param.point && param.point.y < 40) {
            this.resetAutoScale();
            updateStatus("Auto-scaling reset");
          }
        });
      }
      
      autoScaleToVisible() {
        const timeRange = this.chart.timeScale().getVisibleRange();
        if (!timeRange) return;
        
        const seriesData = this.series.data();
        if (!seriesData || seriesData.length === 0) return;
        
        // Filter to visible data
        const visibleData = seriesData.filter(candle => 
          candle.time >= timeRange.from && candle.time <= timeRange.to
        );
        
        if (visibleData.length === 0) return;
        
        // Find range
        let minPrice = Infinity;
        let maxPrice = -Infinity;
        
        visibleData.forEach(candle => {
          minPrice = Math.min(minPrice, candle.low);
          maxPrice = Math.max(maxPrice, candle.high);
        });
        
        // Add margins
        const range = maxPrice - minPrice;
        const topMargin = range * this.margins.top;
        const bottomMargin = range * this.margins.bottom;
        
        // Apply scale
        this.chart.priceScale('right').applyOptions({
          autoScale: false,
          scaleMargins: {
            top: 0.1,
            bottom: 0.1
          }
        });
        
        // Set range
        this.series.priceScale().applyOptions({
          autoScale: false
        });
        
        this.chart.priceScale('right').setVisibleRange({
          from: minPrice - bottomMargin,
          to: maxPrice + topMargin
        });
        
        updateStatus(`Auto-scaled to range: ${(minPrice - bottomMargin).toFixed(5)} - ${(maxPrice + topMargin).toFixed(5)}`);
      }
      
      resetAutoScale() {
        this.isManualScale = false;
        this.chart.priceScale('right').applyOptions({ 
          autoScale: true,
          scaleMargins: {
            top: this.margins.top / 2,
            bottom: this.margins.bottom / 2
          }
        });
        updateStatus("Reset to auto-scale mode");
      }
      
      fitContent() {
        this.chart.priceScale('right').applyOptions({ autoScale: true });
        setTimeout(() => {
          this.autoScaleToVisible();
        }, 50);
        updateStatus("Fitted content with SmartScaling");
      }
    }
    
    // Chart instances
    let chart = null;
    let candleSeries = null;
    let smartScaling = null;
    let isAutoScale = true;
    
    // Update status
    function updateStatus(message) {
      document.getElementById('status').textContent = "Status: " + message;
    }
    
    // Initialize chart
    function initChart() {
      const container = document.getElementById('chart');
      
      chart = LightweightCharts.createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: {
          background: { color: '#1a1a1a' },
          textColor: '#d9d9d9',
        },
        grid: {
          vertLines: { color: '#2a2a2a' },
          horzLines: { color: '#2a2a2a' },
        },
        timeScale: {
          borderColor: '#3a3a3a',
          timeVisible: true,
        },
        rightPriceScale: {
          borderColor: '#3a3a3a',
          scaleMargins: {
            top: 0.2,
            bottom: 0.1,
          },
          mode: 0,
          autoScale: true,
        },
      });
      
      // Create candlestick series
      candleSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        priceFormat: {
          type: 'price',
          precision: 5,
          minMove: 0.00001,
        },
      });
      
      // Initialize smart scaling
      smartScaling = new SmartScaling(chart, candleSeries);
      
      updateStatus("Chart initialized with SmartScaling");
    }
    
    // Generate test data
    function generateTestData() {
      const data = [];
      const startTime = new Date(Date.UTC(2025, 4, 1, 0, 0, 0));
      const startPrice = 1.0850;
      let price = startPrice;
      
      // Generate 30 days of hourly data
      for (let d = 0; d < 30; d++) {
        for (let h = 0; h < 24; h++) {
          const time = new Date(startTime);
          time.setUTCDate(time.getUTCDate() + d);
          time.setUTCHours(h);
          
          // Add some intraday volatility
          const volatility = 0.0005 + (Math.random() * 0.0010);
          
          // Add daily trend
          const trend = (Math.random() > 0.4 ? 1 : -1) * 0.0002;
          
          price += trend;
          
          const open = price;
          const high = price + (Math.random() * volatility);
          const low = price - (Math.random() * volatility);
          const close = price + (Math.random() * volatility * 2 - volatility);
          
          // Update price for next candle
          price = close;
          
          // Add candle
          data.push({
            time: Math.floor(time.getTime() / 1000),
            open: open,
            high: high,
            low: low,
            close: close,
          });
        }
      }
      
      console.log('Generated test data:', data.length, 'candles');
      return data;
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      initChart();
      
      // Load test data immediately
      function loadTestData() {
        updateStatus("Generating test data...");
        
        const data = generateTestData();
        candleSeries.setData(data);
        
        smartScaling.fitContent();
        chart.timeScale().fitContent();
        
        updateStatus(`Loaded ${data.length} candles`);
      }
      
      // Load data button
      document.getElementById('load-data').addEventListener('click', loadTestData);
      
      // Load initial data
      setTimeout(loadTestData, 500);
      
      // Fit chart button
      document.getElementById('fit-chart').addEventListener('click', () => {
        smartScaling.fitContent();
        chart.timeScale().fitContent();
        updateStatus("Chart fitted with SmartScaling");
      });
      
      // Toggle auto-scale button
      document.getElementById('toggle-auto').addEventListener('click', () => {
        isAutoScale = !isAutoScale;
        
        if (isAutoScale) {
          chart.priceScale('right').applyOptions({ autoScale: true });
          updateStatus("Auto-scale enabled");
        } else {
          chart.priceScale('right').applyOptions({ autoScale: false });
          updateStatus("Auto-scale disabled");
        }
      });
      
      // Zoom buttons
      document.getElementById('zoom-in').addEventListener('click', () => {
        const visibleRange = chart.timeScale().getVisibleRange();
        if (!visibleRange) return;
        
        const middle = (visibleRange.from + visibleRange.to) / 2;
        const range = visibleRange.to - visibleRange.from;
        
        chart.timeScale().setVisibleRange({
          from: middle - range / 4,
          to: middle + range / 4,
        });
        
        updateStatus("Zoomed in 50%");
      });
      
      document.getElementById('zoom-out').addEventListener('click', () => {
        const visibleRange = chart.timeScale().getVisibleRange();
        if (!visibleRange) return;
        
        const middle = (visibleRange.from + visibleRange.to) / 2;
        const range = visibleRange.to - visibleRange.from;
        
        chart.timeScale().setVisibleRange({
          from: middle - range,
          to: middle + range,
        });
        
        updateStatus("Zoomed out 200%");
      });
    });
  </script>
</body>
</html>